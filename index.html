<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Childrenâ€™s use of AI</title>
    <script src="./camera_utils.js" crossorigin="anonymous"></script>
    <script src="./drawing_utils.js" crossorigin="anonymous"></script>
    <script src="./pose.js" crossorigin="anonymous"></script>
    <!-- <script src="./pose_solution_packed_assets_loader.js"></script>
    <script src="./pose_solution_simd_wasm_bin.js"></script> -->
    <!-- 
    <script src="./pose_landmark_full.tflite"></script> 
    This is not a JavaScript file and should not be included as a script tag.
    The model is loaded by MediaPipe Pose through the locateFile option.
    -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/@google/generative-ai@0.19.0/dist/generative-ai.js"></script> -->
    <style>
        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            color: #fff;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        video {
            display: none;
        }

        canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        #output_canvas {
            z-index: 1;
        }

        .control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(0, 255, 255, 0.5);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            z-index: 10;
            min-width: 250px;
        }

        .score-display {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
        }

        .music-info {
            font-size: 16px;
            margin-bottom: 10px;
            color: #f0f;
            text-shadow: 0 0 10px #f0f;
        }

        .ai-commentary {
            font-size: 14px;
            color: #ff0;
            text-shadow: 0 0 10px #ff0;
            min-height: 40px;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0c0c2b, #1a1a40);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .floating-element {
            position: absolute;
            font-size: 28px;
            font-weight: bold;
            user-select: none;
            pointer-events: none;
            z-index: 5;
            text-shadow: 0 0 10px currentColor;
            animation: float 4s ease-in-out infinite;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100px;
            /* è®¾ç½®å›ºå®šå®½åº¦ */
            height: 120px;
            /* è®¾ç½®å›ºå®šé«˜åº¦ */
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0px) rotate(0deg);
            }

            50% {
                transform: translateY(-20px) rotate(10deg);
            }
        }

        .particle {
            position: absolute;
            pointer-events: none;
            z-index: 4;
            border-radius: 50%;
        }

        .status-text {
            margin-top: 20px;
            font-size: 18px;
            text-align: center;
        }
    </style>
</head>

<body>
    <div id="loading" class="loading-overlay">
        <h2>Initializing Cyberpunk Experience...</h2>
        <p>Loading MediaPipe Pose & AI Models</p>
        <div class="status-text" id="loading-status">Setting up camera...</div>
    </div>

    <div class="container">
        <video id="input_video"></video>
        <canvas id="output_canvas"></canvas>

        <div class="control-panel">
            <div class="score-display">Score: <span id="score">0</span></div>
            <div class="music-info">Track: Cyberpunk Groove</div>
            <div class="ai-commentary" id="ai-comment">Get ready to move!</div>
        </div>
    </div>

    <script type="module">
        // DOM Elements
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const loadingScreen = document.getElementById('loading');
        const loadingStatus = document.getElementById('loading-status');
        const scoreElement = document.getElementById('score');
        const aiCommentElement = document.getElementById('ai-comment');

        // Game state
        let score = 0;
        let floatingElements = [];
        let particles = [];
        let audioContext;
        let analyser;
        let audioElement;
        let frequencyData;
        let collisionSound; // æ·»åŠ ç¢°æ’éŸ³æ•ˆå˜é‡
        let speechSynthesis; // æ·»åŠ è¯­éŸ³åˆæˆåŠŸèƒ½

        // Initialize audio
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                frequencyData = new Uint8Array(analyser.frequencyBinCount);

                // Create audio element
                audioElement = new Audio();
                audioElement.crossOrigin = "anonymous";
                audioElement.loop = true;

                // For demo purposes, we'll use a data URI for a short beep sound
                audioElement.src = "data:audio/mp3;base64,SUQzBAAAAAABEVRYWFgAAAAtAAADY29tbWVudABCaWdTb3VuZEJhbmsuY29tIC8gTGFTb25vdGhlcXVlLm9yZwBURU5DAAAAHQAAA1N3aXRjaCBQbHVzIMKpIE5DSCBTb2Z0d2FyZQBUSVQyAAAABgAAAzIyMzUAVFNTRQAAAA8AAANMYXZmNTcuODMuMTAwAAAAAAAAAAAAAAD/80DEAAAAA0gAAAAATEFNRTMuMTAwVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/zQsRbAAADSAAAAABVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/zQMSkAAADSAAAAABVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV";

                const source = audioContext.createMediaElementSource(audioElement);
                source.connect(analyser);
                analyser.connect(audioContext.destination);

                audioElement.play().catch(e => console.log("Audio play error:", e));

                // åˆå§‹åŒ–ç¢°æ’éŸ³æ•ˆ
                initCollisionSound();

                // åˆå§‹åŒ–è¯­éŸ³åˆæˆåŠŸèƒ½
                speechSynthesis = window.speechSynthesis;
            } catch (e) {
                console.log("Web Audio API is not supported in this browser", e);
            }
        }

        // åˆå§‹åŒ–ç¢°æ’éŸ³æ•ˆ
        function initCollisionSound() {
            try {
                // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                const ctx = new AudioContext();

                // åˆ›å»ºæ›´æœ‰è¶£çš„å„¿ç«¥å‹å¥½å‹éŸ³æ•ˆ
                collisionSound = function () {
                    // åˆ›å»ºå¤šä¸ªæŒ¯è¡å™¨åˆ¶é€ å’Œå¼¦æ•ˆæœ
                    const oscillator1 = ctx.createOscillator();
                    const oscillator2 = ctx.createOscillator();
                    const oscillator3 = ctx.createOscillator();
                    const gainNode = ctx.createGain();

                    // æ·»åŠ æ»¤æ³¢å™¨åˆ¶é€ æ›´ä¸°å¯Œçš„éŸ³è‰²
                    const filter = ctx.createBiquadFilter();
                    filter.type = "lowpass";
                    filter.frequency.value = 1000;

                    // è®¾ç½®æŒ¯è¡å™¨ç±»å‹å’Œé¢‘ç‡ï¼Œåˆ›é€ æ„‰æ‚¦çš„å’Œå¼¦
                    oscillator1.type = 'sine';
                    oscillator1.frequency.value = 523.25; // C5

                    oscillator2.type = 'sine';
                    oscillator2.frequency.value = 659.25; // E5

                    oscillator3.type = 'triangle';
                    oscillator3.frequency.value = 783.99; // G5

                    // æ·»åŠ ä¸€äº›éšæœºæ€§ä½¿æ¯æ¬¡ç¢°æ’ç•¥æœ‰ä¸åŒ
                    const randomness = Math.random() * 50;
                    oscillator1.frequency.value += randomness;
                    oscillator2.frequency.value += randomness;
                    oscillator3.frequency.value += randomness;

                    // è®¾ç½®éŸ³é‡åŒ…ç»œï¼Œè®©å£°éŸ³æœ‰"ç °"çš„æ„Ÿè§‰
                    gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);

                    // è¿æ¥èŠ‚ç‚¹ï¼šæŒ¯è¡å™¨ -> æ»¤æ³¢å™¨ -> éŸ³é‡æ§åˆ¶ -> è¾“å‡º
                    oscillator1.connect(filter);
                    oscillator2.connect(filter);
                    oscillator3.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(ctx.destination);

                    // å¯åŠ¨æŒ¯è¡å™¨
                    oscillator1.start();
                    oscillator2.start();
                    oscillator3.start();

                    // ä¸€æ®µæ—¶é—´ååœæ­¢
                    oscillator1.stop(ctx.currentTime + 0.4);
                    oscillator2.stop(ctx.currentTime + 0.4);
                    oscillator3.stop(ctx.currentTime + 0.4);
                };
            } catch (e) {
                console.log("Web Audio API is not supported", e);
                // å¦‚æœWeb Audio APIä¸å¯ç”¨ï¼Œå›é€€åˆ°ç®€å•éŸ³æ•ˆ
                collisionSound = function () {
                    const fallbackSound = new Audio();
                    fallbackSound.src = "data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFfHp8fHx9fX1+fn5/f3+AgIGCg4OEhYaHiImKi4yNjo+QkZKTlJWWl5iZmpucnZ6foKGio6SlpqeoqaqrrK2ur7CxsrO0tba3uLm6u7y9vr/AwcLDxMXGx8jJysvMzc7P0NHS09TV1tfY2drb3N3e3+Dh4uPk5ebn6Onq6+zt7u/w8fLz9PX29/j5+vv8/f7/AAECAwQFBgcICQoLDA0ODg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v8A";
                    fallbackSound.play().catch(e => console.log("Sound play error:", e));
                };
            }
        }

        // æ’­æ”¾æ°´æœåç§°è¯­éŸ³
        // ...existing code...
        function speakFruitName(fruitName) {
            try {
                // åœæ­¢å¹¶æ¸…ç†ä¸Šä¸€ä¸ªæ’­æ”¾å®ä¾‹ï¼ˆå¦‚æœæœ‰ï¼‰
                if (window._ttsAudio && !window._ttsAudio.paused) {
                    window._ttsAudio.pause();
                    window._ttsAudio.currentTime = 0;
                }

                // ç®€å•ç¼“å­˜å·²ç”Ÿæˆçš„éŸ³é¢‘ URLï¼Œå‡å°‘é‡å¤è¯·æ±‚
                window._ttsCache = window._ttsCache || {};
                if (window._ttsCache[fruitName]) {
                    const cachedAudio = new Audio(window._ttsCache[fruitName]);
                    cachedAudio.crossOrigin = 'anonymous';
                    cachedAudio.play().catch(e => console.log('TTS play error:', e));
                    window._ttsAudio = cachedAudio;
                    return;
                }

                // è¯·æ±‚ textreadtts æœåŠ¡ä»¥è·å–éŸ³é¢‘ URL
                const apiUrl = `https://textreadtts.com/tts/convert?accessKey=FREE&language=english&speaker=speaker5&text=${encodeURIComponent(fruitName)}`;
                fetch(apiUrl)
                    .then(resp => resp.json())
                    .then(json => {
                        if (json && json.code === 0 && json.audio) {
                            window._ttsCache[fruitName] = json.audio;
                            const audio = new Audio(json.audio);
                            audio.crossOrigin = 'anonymous';
                            audio.play().catch(e => console.log('TTS play error:', e));
                            window._ttsAudio = audio;
                        } else {
                            console.log('TTS response error:', json);
                        }
                    })
                    .catch(err => {
                        console.log('TTS fetch error:', err);
                    });
            } catch (e) {
                console.log("TTS error:", e);
            }
        }
        // ...existing code...

        // Create floating elements
        function createFloatingElements() {
            const fruits = [
                { emoji: 'ğŸ', name: 'Apple' },
                { emoji: 'ğŸŒ', name: 'Banana' },
                { emoji: 'ğŸ‡', name: 'Grapes' },
                { emoji: 'ğŸ“', name: 'Strawberry' },
                { emoji: 'ğŸŠ', name: 'Orange' },
                { emoji: 'ğŸ‘', name: 'Peach' },
                { emoji: 'ğŸ', name: 'Pineapple' },
                { emoji: 'ğŸ¥', name: 'Kiwi' },
                { emoji: 'ğŸ¥¥', name: 'Coconut' },
                { emoji: 'ğŸ‰', name: 'Watermelon' }
            ];

            // åªåˆ›å»ºä¸€ä¸ªæ°´æœè€Œä¸æ˜¯10ä¸ª
            const fruit = fruits[Math.floor(Math.random() * fruits.length)];

            const element = document.createElement('div');
            element.className = 'floating-element';

            // å¢å¤§æ°´æœå…ƒç´ çš„å°ºå¯¸ï¼ˆä»30pxå¢åŠ åˆ°60pxï¼Œæ–‡å­—ä»14pxå¢åŠ åˆ°24pxï¼‰
            element.innerHTML = `
                <div style="text-align: center;">
                    <div style="font-size: 60px;">${fruit.emoji}</div>
                    <div style="font-size: 24px; margin-top: 10px;">${fruit.name}</div>
                </div>
            `;

            element.style.left = Math.random() * 80 + 10 + '%';
            element.style.top = Math.random() * 80 + 10 + '%';
            element.style.color = `hsl(${Math.random() * 360}, 100%, 70%)`;
            element.style.animationDelay = Math.random() * 2 + 's';
            element.dataset.id = 0;
            element.addEventListener('click', () => {
                // ç‚¹å‡»æ—¶ä¹Ÿæ’­æ”¾è¯­éŸ³ï¼ˆæ–¹ä¾¿æµ‹è¯•ï¼‰
                speakFruitName(fruit.name);
            });
            document.body.appendChild(element);

            floatingElements.push({
                element: element,
                x: parseFloat(element.style.left),
                y: parseFloat(element.style.top),
                width: 100,  // å¢åŠ å®½åº¦ä»¥é€‚åº”æ›´å¤§çš„å…ƒç´ 
                height: 120  // å¢åŠ é«˜åº¦ä»¥é€‚åº”æ›´å¤§çš„å…ƒç´ 
            });
        }

        // Create particle explosion
        function createParticles(x, y, color) {
            for (let i = 0; i < 15; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                particle.style.backgroundColor = color;
                particle.style.width = '8px';
                particle.style.height = '8px';
                document.body.appendChild(particle);

                particles.push({
                    element: particle,
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 100
                });
            }
        }

        // Update particles
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 2;

                p.element.style.left = p.x + 'px';
                p.element.style.top = p.y + 'px';
                p.element.style.opacity = p.life / 100;

                if (p.life <= 0) {
                    p.element.remove();
                    particles.splice(i, 1);
                }
            }
        }

        // Check collisions for both nose and hands
        function checkCollisions(noseX, noseY, leftHandX, leftHandY, rightHandX, rightHandY) {
            for (let i = floatingElements.length - 1; i >= 0; i--) {
                const elem = floatingElements[i];
                const elemX = (elem.x / 100) * window.innerWidth;
                const elemY = (elem.y / 100) * window.innerHeight;

                // è°ƒæ•´ç¢°æ’æ£€æµ‹åŒºåŸŸä»¥é€‚åº”æ–°çš„æ°´æœå…ƒç´ å¤§å°
                const centerX = elemX + 50;  // å…ƒç´ å®½åº¦çš„ä¸€åŠ (100/2)
                const centerY = elemY + 60;  // å…ƒç´ é«˜åº¦çš„ä¸€åŠ (120/2)

                // æ£€æŸ¥é¼»å­ç¢°æ’
                const noseDistance = Math.sqrt(Math.pow(noseX - centerX, 2) + Math.pow(noseY - centerY, 2));

                // æ£€æŸ¥å·¦æ‰‹ç¢°æ’
                let leftHandDistance = Infinity;
                if (leftHandX && leftHandY) {
                    leftHandDistance = Math.sqrt(Math.pow(leftHandX - centerX, 2) + Math.pow(leftHandY - centerY, 2));
                }

                // æ£€æŸ¥å³æ‰‹ç¢°æ’
                let rightHandDistance = Infinity;
                if (rightHandX && rightHandY) {
                    rightHandDistance = Math.sqrt(Math.pow(rightHandX - centerX, 2) + Math.pow(rightHandY - centerY, 2));
                }

                // å¦‚æœä»»ä¸€ç‚¹è·ç¦»è¶³å¤Ÿè¿‘ï¼Œå°±è§¦å‘ç¢°æ’
                if (noseDistance < 50 || leftHandDistance < 50 || rightHandDistance < 50) {
                    // è·å–æ°´æœåç§°å¹¶æ’­æ”¾è¯­éŸ³ 
                    // const fruitName = elem.element.querySelector('div:last-child').textContent;
                    const fruitName = document.querySelector('body > div.floating-element > div > div:nth-child(2)').textContent;
                    console.log('ç¢°æ’çš„æ°´æœåç§°', fruitName);
                    speakFruitName(fruitName);

                    // Collision detected
                    createParticles(centerX, centerY, elem.element.style.color);

                    // æ’­æ”¾ç¢°æ’éŸ³æ•ˆ
                    if (collisionSound) {
                        try {
                            collisionSound();
                        } catch (e) {
                            console.log("Sound play error:", e);
                        }
                    }

                    elem.element.remove();
                    floatingElements.splice(i, 1);
                    score += 10;
                    scoreElement.textContent = score;

                    // Add new element
                    setTimeout(() => {
                        const fruits = [
                            { emoji: 'ğŸ', name: 'Apple' },
                            { emoji: 'ğŸŒ', name: 'Banana' },
                            { emoji: 'ğŸ‡', name: 'Grapes' },
                            { emoji: 'ğŸ“', name: 'Strawberry' },
                            { emoji: 'ğŸŠ', name: 'Orange' },
                            { emoji: 'ğŸ‘', name: 'Peach' },
                            { emoji: 'ğŸ', name: 'Pineapple' },
                            { emoji: 'ğŸ¥', name: 'Kiwi' },
                            { emoji: 'ğŸ¥¥', name: 'Coconut' },
                            { emoji: 'ğŸ‰', name: 'Watermelon' }
                        ];

                        const fruit = fruits[Math.floor(Math.random() * fruits.length)];

                        const element = document.createElement('div');
                        element.className = 'floating-element';

                        // å¢å¤§æ°´æœå…ƒç´ çš„å°ºå¯¸ï¼ˆä»30pxå¢åŠ åˆ°60pxï¼Œæ–‡å­—ä»14pxå¢åŠ åˆ°24pxï¼‰
                        element.innerHTML = `
                            <div style="text-align: center;">
                                <div style="font-size: 60px;">${fruit.emoji}</div>
                                <div style="font-size: 24px; margin-top: 10px;">${fruit.name}</div>
                            </div>
                        `;

                        element.style.left = Math.random() * 80 + 10 + '%';
                        element.style.top = Math.random() * 80 + 10 + '%';
                        element.style.color = `hsl(${Math.random() * 360}, 100%, 70%)`;
                        element.style.animationDelay = Math.random() * 2 + 's';
                        document.body.appendChild(element);

                        floatingElements.push({
                            element: element,
                            x: parseFloat(element.style.left),
                            y: parseFloat(element.style.top),
                            width: 100,  // å¢åŠ å®½åº¦ä»¥é€‚åº”æ›´å¤§çš„å…ƒç´ 
                            height: 120  // å¢åŠ é«˜åº¦ä»¥é€‚åº”æ›´å¤§çš„å…ƒç´ 
                        });
                    }, 300);
                }
            }
        }

        // Generate AI commentary
        async function generateAICommentary() {
            // In a real implementation, this would call the Gemini API
            // For this demo, we'll simulate AI responses
            const comments = [
                "Wow! Great moves!",
                "You're doing fantastic!",
                "Keep grooving!",
                "Amazing energy!",
                "That's the spirit!",
                "Incredible flow!",
                "You're unstoppable!",
                "Dance like nobody's watching!",
                "Feel the rhythm!",
                "Absolutely brilliant!"
            ];

            const randomComment = comments[Math.floor(Math.random() * comments.length)];
            aiCommentElement.textContent = randomComment;
        }

        // Initialize MediaPipe Pose
        loadingStatus.textContent = "Loading MediaPipe Pose...";
        const pose = new Pose({
            locateFile: (file) => {
                if (file.endsWith('.tflite') || file.endsWith('.data') || file.endsWith('wasm') || file.endsWith('binarypb') || file.endsWith('js')) {
                    // å¯¹äº.tfliteæ–‡ä»¶ï¼Œä½¿ç”¨æœ¬åœ°æ–‡ä»¶
                    return `./${file}`;
                }
                // å…¶ä»–æ–‡ä»¶ä»ç„¶ä»CDNåŠ è½½
                return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
            }
        });

        pose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        // Handle pose results
        function onResults(results) {
            // Hide loading screen on first frame
            if (loadingScreen.style.display !== 'none') {
                loadingScreen.style.display = 'none';
            }

            // Clear canvas
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            // Draw image with mirroring effect (like a mirror)
            canvasCtx.save();
            canvasCtx.translate(canvasElement.width, 0);
            canvasCtx.scale(-1, 1);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.restore();

            // Draw pose landmarks
            if (results.poseLandmarks) {
                // Get audio frequency data if available
                let amplitude = 1;
                if (analyser) {
                    analyser.getByteFrequencyData(frequencyData);
                    // Calculate average amplitude
                    let sum = 0;
                    for (let i = 0; i < frequencyData.length; i++) {
                        sum += frequencyData[i];
                    }
                    amplitude = 1 + (sum / frequencyData.length) / 50;
                }

                // Apply mirroring to pose landmarks
                const mirroredPoseLandmarks = results.poseLandmarks.map(landmark => {
                    return {
                        ...landmark,
                        x: 1 - landmark.x  // Mirror the x-coordinate
                    };
                });

                // Draw connections with neon style
                drawConnectors(canvasCtx, mirroredPoseLandmarks, POSE_CONNECTIONS,
                    { color: '#00FFFF', lineWidth: 2 * amplitude });

                // Draw landmarks
                drawLandmarks(canvasCtx, mirroredPoseLandmarks,
                    { color: '#FF00FF', lineWidth: 1, radius: 3 * amplitude });

                // Use nose landmark for interaction (landmark 0)
                const nose = mirroredPoseLandmarks[0];
                const noseX = nose.x * canvasElement.width;
                const noseY = nose.y * canvasElement.height;

                // Draw larger nose point for visibility
                canvasCtx.beginPath();
                canvasCtx.arc(noseX, noseY, 10 * amplitude, 0, 2 * Math.PI);
                canvasCtx.fillStyle = '#FFFF00';
                canvasCtx.fill();

                // è·å–å·¦å³æ‰‹çš„å…³é”®ç‚¹åæ ‡
                // è®¡ç®—æ¯åªæ‰‹çš„æ‰‹æŒä¸­å¿ƒç‚¹
                let leftHandX, leftHandY, rightHandX, rightHandY;
                let leftHandVisible = false, rightHandVisible = false;

                // å·¦æ‰‹æŒä¸­å¿ƒè®¡ç®—ï¼ˆåŸºäºæ‰‹è…•å’Œæ‰‹æŒ‡æ ¹éƒ¨å…³é”®ç‚¹ï¼‰
                // å·¦æ‰‹å…³é”®ç‚¹: 15 (æ‰‹è…•), 17 (é£ŸæŒ‡æ ¹éƒ¨), 19 (ä¸­æŒ‡æ ¹éƒ¨), 21 (å°æŒ‡æ ¹éƒ¨)
                if (mirroredPoseLandmarks[15] && mirroredPoseLandmarks[17] && mirroredPoseLandmarks[19] &&
                    mirroredPoseLandmarks[21]) {
                    // æ£€æŸ¥å…³é”®ç‚¹çš„å¯è§åº¦ï¼ˆä½¿ç”¨è¾ƒä½çš„é˜ˆå€¼ç¡®ä¿æ›´å¥½åœ°æ˜¾ç¤ºï¼‰
                    leftHandVisible = mirroredPoseLandmarks[15].visibility > 0.1 &&
                        mirroredPoseLandmarks[17].visibility > 0.1 &&
                        mirroredPoseLandmarks[19].visibility > 0.1 &&
                        mirroredPoseLandmarks[21].visibility > 0.1;

                    if (leftHandVisible) {
                        // è®¡ç®—å·¦æ‰‹æŒä¸­å¿ƒï¼ˆæ‰‹è…•å’Œä¸‰ä¸ªæ‰‹æŒ‡æ ¹éƒ¨çš„å¹³å‡ä½ç½®ï¼‰
                        leftHandX = (mirroredPoseLandmarks[15].x + mirroredPoseLandmarks[17].x +
                            mirroredPoseLandmarks[19].x + mirroredPoseLandmarks[21].x) / 4 * canvasElement.width;
                        leftHandY = (mirroredPoseLandmarks[15].y + mirroredPoseLandmarks[17].y +
                            mirroredPoseLandmarks[19].y + mirroredPoseLandmarks[21].y) / 4 * canvasElement.height;

                        // ç»˜åˆ¶å·¦æ‰‹ç‚¹
                        canvasCtx.beginPath();
                        canvasCtx.arc(leftHandX, leftHandY, 10 * amplitude, 0, 2 * Math.PI);
                        canvasCtx.fillStyle = '#00FF00';
                        canvasCtx.fill();
                    }
                }

                // å³æ‰‹æŒä¸­å¿ƒè®¡ç®—ï¼ˆåŸºäºæ‰‹è…•å’Œæ‰‹æŒ‡æ ¹éƒ¨å…³é”®ç‚¹ï¼‰
                // å³æ‰‹å…³é”®ç‚¹: 16 (æ‰‹è…•), 18 (é£ŸæŒ‡æ ¹éƒ¨), 20 (ä¸­æŒ‡æ ¹éƒ¨), 22 (å°æŒ‡æ ¹éƒ¨)
                if (mirroredPoseLandmarks[16] && mirroredPoseLandmarks[18] && mirroredPoseLandmarks[20] &&
                    mirroredPoseLandmarks[22]) {
                    // æ£€æŸ¥å…³é”®ç‚¹çš„å¯è§åº¦ï¼ˆä½¿ç”¨è¾ƒä½çš„é˜ˆå€¼ç¡®ä¿æ›´å¥½åœ°æ˜¾ç¤ºï¼‰
                    rightHandVisible = mirroredPoseLandmarks[16].visibility > 0.1 &&
                        mirroredPoseLandmarks[18].visibility > 0.1 &&
                        mirroredPoseLandmarks[20].visibility > 0.1 &&
                        mirroredPoseLandmarks[22].visibility > 0.1;

                    if (rightHandVisible) {
                        // è®¡ç®—å³æ‰‹æŒä¸­å¿ƒï¼ˆæ‰‹è…•å’Œä¸‰ä¸ªæ‰‹æŒ‡æ ¹éƒ¨çš„å¹³å‡ä½ç½®ï¼‰
                        rightHandX = (mirroredPoseLandmarks[16].x + mirroredPoseLandmarks[18].x +
                            mirroredPoseLandmarks[20].x + mirroredPoseLandmarks[22].x) / 4 * canvasElement.width;
                        rightHandY = (mirroredPoseLandmarks[16].y + mirroredPoseLandmarks[18].y +
                            mirroredPoseLandmarks[20].y + mirroredPoseLandmarks[22].y) / 4 * canvasElement.height;

                        // ç»˜åˆ¶å³æ‰‹ç‚¹
                        canvasCtx.beginPath();
                        canvasCtx.arc(rightHandX, rightHandY, 10 * amplitude, 0, 2 * Math.PI);
                        canvasCtx.fillStyle = '#00FF00';
                        canvasCtx.fill();
                    }
                }

                // Check for collisions with nose and hands (only check visible hands)
                checkCollisions(
                    noseX, noseY,
                    leftHandVisible ? leftHandX : null,
                    leftHandVisible ? leftHandY : null,
                    rightHandVisible ? rightHandX : null,
                    rightHandVisible ? rightHandY : null
                );
            }
        }

        pose.onResults(onResults);

        // Initialize camera
        loadingStatus.textContent = "Accessing camera...";
        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await pose.send({ image: videoElement });
            },
            width: 1280,
            height: 720
        });

        // Handle window resize
        function resizeCanvas() {
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Start everything
        Promise.all([
            camera.start().catch(err => {
                loadingStatus.textContent = "Camera access denied. Please allow camera access.";
                console.error("Camera error:", err);
            }),
            new Promise(resolve => {
                setTimeout(() => {
                    initAudio();
                    createFloatingElements();
                    resolve();
                }, 1000);
            })
        ]).then(() => {
            // Start AI commentary updates
            setInterval(generateAICommentary, 5000);

            // Start particle updates
            function gameLoop() {
                updateParticles();
                requestAnimationFrame(gameLoop);
            }
            gameLoop();
        }).catch(err => {
            console.error("Initialization error:", err);
        });
    </script>
</body>

</html>